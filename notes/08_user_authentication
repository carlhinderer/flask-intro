-----------------------------------------------------------------------
|  CHAPTER 8 - USER AUTHENTICATION                                    |
-----------------------------------------------------------------------

- There are many excellent Python authentication packages, but none of them do everything.
    Here, we'll use several packages and provide the glue that holds them together.

  Authentication Packages:

    1. Flask-Login
         Management of user sessions for logged-in users

    2. Werkzeug
         Password hashing and verification

    3. itsdangerous
         Cryptographically secure token generation and verification



- Hashing Passwords with Werkzeug

    - Werzkeug's 'security' module conveniently implements secure password hashing.  It's
        functionality is exposed with 2 simple functions.


        # Takes in plain-text password and returns the password hash
        generate_password_hash(password, method='pbkdf2:sha256', salt_length=8)

        # Takes in password and hash, and returns True if they are the same
        check_password_hash(hash, password)


    - We'll update the 'User' model to accomodate password hashing.


        from werkzeug.security import generate_password_hash, check_password_hash

        class User(db.Model):
            # ...
            password_hash = db.Column(db.String(128))
        
            @property
            def password(self):
                raise AttributeError('password is not a readable attribute')
        
            @password.setter
            def password(self, password):
                self.password_hash = generate_password_hash(password)
        
            def verify_password(self, password):
                return check_password_hash(self.password_hash, password)


    - We can test the password hashing in the shell.

        >>> u = User()
        >>> u.password = 'cat'

        >>> u.password
        AttributeError: password is not a readable attribute

        >>> u.password_hash
        'pbkdf2:sha256:50000$moHwFH1B$ef1574909f9c549285e8547cad181c5e0213cfa44a4aba4349
        fa830aa1fd227f'

        >>> u.verify_password('cat')
        True
        >>> u.verify_password('dog')
        exit
        False



- Testing the Password Hashing

    - We can add tests for the User model:

        # tests/test_user_model.py

        import unittest
        from app.models import User
        
        class UserModelTestCase(unittest.TestCase):
            def test_password_setter(self):
                u = User(password = 'cat')
                self.assertTrue(u.password_hash is not None)
        
            def test_no_password_getter(self):
                u = User(password = 'cat')
                with self.assertRaises(AttributeError):
                    u.password
        
            def test_password_verification(self):
                u = User(password = 'cat')
                self.assertTrue(u.verify_password('cat'))
                self.assertFalse(u.verify_password('dog'))
        
            def test_password_salts_are_random(self):
                u = User(password='cat')
                u2 = User(password='cat')
                self.assertTrue(u.password_hash != u2.password_hash)



- Creating an Authentication Blueprint

    - Blueprints were used in Chapter 7 to define routes in the global scope after the creation
        of the application was moved into a factory function.  In this section, we'll add the
        routes related to the user authentication subsystem into a second blueprint called 'auth'.

      The 'auth' blueprint will be hosted in a Python package with the same name.  


        # app/auth/__init__.py
        from flask import Blueprint

        auth = Blueprint('auth', __name__)

        from . import views


    - Here, we define the route.


        # app/auth/views.py
        from flask import render_template
        from . import auth

        @auth.route('/login')
        def login():
            return render_template('auth/login.html')


    - Also, we need to add the auth blueprint to the 'create_app()' factory function.


        def create_app(config_name):
            # ...
            from .auth import auth as auth_blueprint
            app.register_blueprint(auth_blueprint, url_prefix='/auth')
        
            return app



- User Authentication for Flask-Login

    - Flask-Login is an extension that keeps track of whether users are loggin in.  It can be
        used with any authentication system.

        $ pip install flask-login



- Preparing the User Model for Logins

    - Flask-Login requires these properties on the 'User' model.

        Property/method         Description
        ---------------------------------------------------------------------------------
        is_authenticated        Must be True if the user has valid login credentials or False 
                                  otherwise.

        is_active               Must be True if the user is allowed to log in or False otherwise. 
                                  A False value can be used for disabled accounts.

        is_anonymous            Must always be False for regular users and True for a special 
                                  user object that represents anonymous users.

        get_id()               Must return a unique identifier for the user, encoded as a Unicode 
                                  string.


    - We could directly implement these properties and method in the class, but the Flask-Login
        package includes a 'UserMixin' that has default implementations appropriate for most
        cases.  We also add an email address.


        # app/models.py

        from flask_login import UserMixin

        class User(UserMixin, db.Model):
            ...
            email = db.Column(db.String(64), unique=True, index=True)


    - Flask-Login is initialiazed in the application factory function.


        # app/__init__.py

        from flask_login import LoginManager

        # Sets the endpoint for the login page
        # This will automatically redirect anonymous users when they try to access
        #   protected resources.
        login_manager = LoginManager()
        login_manager.login_view = 'auth.login'

        def create_app(config_name):
            # ...
            login_manager.init_app(app)
            # ...


    - Finally, we need to designate a function that will be used to load a user from the 
        database given its identifier.

        # app/models.py

        from . import login_manager

        @login_manager.user_loader
        def load_user(user_id):
            return User.query.get(int(user_id))



- Protecting Routes

    - To protect a route so that it can only by accessed by authenticated users, Flask-Login
        provides a 'login_required' decorator.

      Here is an example:


        from flask_login import login_required

        @app.route('/secret')
        @login_required
        def secret():
            return 'Only authenticated users are allowed!'


    - If the route is accessed by a user that is not authenticated, Flask-Login will redirect
        the user to the login page.



- Adding a Login Form

    - First, we need to install the 'email_validator' extension.

        $ pip install email_validator


    - Well add a login form:

        # app/auth/forms.py
        from flask_wtf import FlaskForm
        from wtforms import StringField, PasswordField, BooleanField, SubmitField
        from wtforms.validators import DataRequired, Length, Email
        
        class LoginForm(FlaskForm):
            email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                                     Email()])
            password = PasswordField('Password', validators=[DataRequired()])
            remember_me = BooleanField('Keep me logged in')
            submit = SubmitField('Log In')


    - And we'll add 'Log In' and 'Log Out' links depending on the logged-in state of the
        state of the current user.  The links are located in the navbar.

        # app/templates/base.html

        ...
        <ul class="nav navbar-nav navbar-right">
            {% if current_user.is_authenticated %}
            <li><a href="{{ url_for('auth.logout') }}">Log Out</a></li>
            {% else %}
            <li><a href="{{ url_for('auth.login') }}">Log In</a></li>
            {% endif %}
        </ul>



- Signing Users In

    - Now, we can implement the 'login()' view function.

        # app/auth/views.py

        from flask import render_template, redirect, request, url_for, flash
        from flask_login import login_user
        from . import auth
        from ..models import User
        from .forms import LoginForm
        
        @auth.route('/login', methods=['GET', 'POST'])
        def login():
            form = LoginForm()
            if form.validate_on_submit():
                user = User.query.filter_by(email=form.email.data).first()
                if user is not None and user.verify_password(form.password.data):
                    login_user(user, form.remember_me.data)
                    next = request.args.get('next')
                    if next is None or not next.startswith('/'):
                        next = url_for('main.index')
                    return redirect(next)
                flash('Invalid username or password.')
            return render_template('auth/login.html', form=form)


    - The 'remember_me' argument sets whether the user should stay logged in after the browser 
        is closed.

      If the value is False, the user session expires when the browser window is closed, so the
        user will have to log in again each time.

      If the value is True, a long-term cookie will be set in the user's browser, which Flask-Login
        uses to restore the user session.  The optional REMEMBER_COOKIE_DURATION configuration 
        option can be used to change the default one-year duration for the remember cookie.


    - If the login was triggered by a user trying to access a protected resource, Flask-Login will
        have saved that original URL in the 'next' query string argument, which can be accessed
        from the 'request.args' dictionary.  Then we can redirect them to the intended page.

      If there isn't any value for 'next', we redirect the user to the home page.  For safety 
        reasons, we check that it starts with '/' before redirecting to it.


    - Finally, we'll create the template for the login form.

        # app/templates/auth/login.html

        {% extends "base.html" %}
        {% import "bootstrap/wtf.html" as wtf %}
        
        {% block title %}Flasky - Login{% endblock %}
        
        {% block page_content %}
        <div class="page-header">
            <h1>Login</h1>
        </div>
        <div class="col-md-4">
            {{ wtf.quick_form(form) }}
        </div>
        {% endblock %}



- Signing Users Out

    - Here is the implementation of the logout route:

        # app/auth/views.py

        from flask_login import logout_user, login_required

        @auth.route('/logout')
        @login_required
        def logout():
            logout_user()
            flash('You have been logged out.')
            return redirect(url_for('main.index'))



- Understanding How Flask-Login Works

    - Here is the sequence of operations that occurs when a user logs into the system:

        1. The user navigates to 'http://localhost:5000/auth/login' after clicking the link,
             which returns the login form template.


        2. The user enters their username and password and clicks 'Submit', which sends a 
             POST request to the same route.

             A. The handler validates the credentials submitted with the form, then invokes
                  Flask-Login's 'login_user()' function to log the user in.

             B. The 'login_user()' function writes the ID of the user to the user session as
                  a string.

             C. The view function returns with a redirect to the home page.


        3. The browser receives the redirect and requests the home page.

             A. The view function for the home page is invoked, and it triggers rendering of
                  the template.

             B. During the rendering of the template, the 'current_user' appears for the first
                  time.

             C. The 'current_user' context variable does not have a value assigned yet, so it
                  invokes Flask-Login's internal function '_get_user()' to get the user's
                  identity.

             D. The '_get_user()' function check if there is a user ID stored in the user session.
                  If there isn't one, an instance of Flask-Login's 'AnonymousUser' class.

                If there is an ID, it invokes the function that the application registered with
                  the 'user_loader' decorator.

             E. The application's 'user_loader' handler reads the user from the database and 
                  returns it.  Flask-Login assigs it to the 'current_user' context variable for
                  the current request.

             F. The template receives the newly assigned value of 'current_user'.


        4. The 'login_required' decorator builds on top of the 'current_user' context variable by
             only allowing the decorated view function to run when 'current_user.is_authenticated'
             is set to True.


        5. The 'logout_user()' simply deletes the user ID from the user session.



- Testing Logins

    - We'll update our home page to display the name of the logged in user.

        # app/templates/index.html
        <h1>
        Hello,
        {% if current_user.is_authenticated %}
            {{ current_user.username }}
        {% else %}
            Stranger
        {% endif %}!
        </h1>


    - To test this, we can just create a user in the flask shell.

        >>> u = User(email='john@example.com', username='john', password='cat')
        >>> db.session.add(u)
        >>> db.session.commit()



- Adding a User Registration Form

    - When new users want to become members of the application, they must register.  We'll
        create a form for them to enter their email, username, and password.


        # app/auth/forms.py

        from flask_wtf import FlaskForm
        from wtforms import StringField, PasswordField, BooleanField, SubmitField
        from wtforms.validators import DataRequired, Length, Email, Regexp, EqualTo
        from wtforms import ValidationError
        from ..models import User
        
        class RegistrationForm(FlaskForm):
            email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                                     Email()])
            username = StringField('Username', validators=[
                DataRequired(), Length(1, 64),
                Regexp('^[A-Za-z][A-Za-z0-9_.]*$', 0,
                       'Usernames must have only letters, numbers, dots or '
                       'underscores')])
            password = PasswordField('Password', validators=[
                DataRequired(), EqualTo('password2', message='Passwords must match.')])
            password2 = PasswordField('Confirm password', validators=[DataRequired()])
            submit = SubmitField('Register')
        
            def validate_email(self, field):
                if User.query.filter_by(email=field.data).first():
                    raise ValidationError('Email already registered.')
        
            def validate_username(self, field):
                if User.query.filter_by(username=field.data).first():
                    raise ValidationError('Username already in use.')


    - And, we'll add a link to the registration page from the login page.

        # app/templates/auth/login.html

        <p>
            New user?
            <a href="{{ url_for('auth.register') }}">
                Click here to register
            </a>
        </p>



- Registering New Users

    - Here is our view method for registering new users.

        # app/auth/views.py

        @auth.route('/register', methods=['GET', 'POST'])
        def register():
            form = RegistrationForm()
            if form.validate_on_submit():
                user = User(email=form.email.data,
                            username=form.username.data,
                            password=form.password.data)
                db.session.add(user)
                db.session.commit()
                flash('You can now login.')
                return redirect(url_for('auth.login'))
            return render_template('auth/register.html', form=form)



- Generating Confirmation Tokens with itsdangerous

    - A common requirement is to confirm a user can be reached via their email request.
        Typically, the account confirmation procedure involves clicking a specially
        crafted link that includes a confirmation code.

        http://www.example.com/auth/confirm/<confirmation-code>


    - Remember that Flask uses cryptographically signed tokens to protect the content of user
        sessions against tampering.  The user session cookies contain a cryptographic 
        signature generated by a package called 'itsdangerous'.  

      If the contents of the user session is altered, the signature will not match the content
        any more, so Flask discards the session and starts a new one.


    - To generate a signed token:

        >>> from itsdangerous import TimedJSONWebSignatureSerializer as Serializer

        >>> s = Serializer(app.config['SECRET_KEY'], expires_in=3600)
        >>> token = s.dumps({ 'confirm': 23 })
        >>> token
        'eyJhbGciOiJIUzI1NiIsImV4cCI6MTM4MTcxODU1OCwiaWF0IjoxMzgxNzE0OTU4fQ.ey ...'

        >>> data = s.loads(token)
        >>> data
        {'confirm': 23}


    - The 'itsdangerous' package provides several types of token generators.  Among them,
        the 'TimedJSONWebSignatureSerializer' generates JSON Web Signatures (JWSs) with a
        time expiration.  

      The 'dumps()' method generates a cryptographic signature for the data given as an
        argument, then serializes the data plus the signature as a convenient token string.
        The 'expires_in' argument sets a

      The 'loads()' method takes the token and decodes it.


    - We'll add the token generation and verification functionality to the User model.

        # app/models.py

        from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
        from flask import current_app
        from . import db
        
        class User(UserMixin, db.Model):
            # ...
            confirmed = db.Column(db.Boolean, default=False)
        
            def generate_confirmation_token(self, expiration=3600):
                s = Serializer(current_app.config['SECRET_KEY'], expiration)
                return s.dumps({'confirm': self.id}).decode('utf-8')
        
            def confirm(self, token):
                s = Serializer(current_app.config['SECRET_KEY'])
                try:
                    data = s.loads(token.encode('utf-8'))
                except:
                    return False
                if data.get('confirm') != self.id:
                    return False
                self.confirmed = True
                db.session.add(self)
                return True


    - The 'confirm()' method verifies the token and also checks that the id from the token
        matches the logged-in user, so that the token for a given user cannot be used to
        confirm a different user.



- Sending Confirmation Emails

    - We now need the 'register()' view method to send the confirmation email before
        redirecting.


        # app/auth/views.py
        from ..email import send_email

        @auth.route('/register', methods=['GET', 'POST'])
        def register():
            form = RegistrationForm()
            if form.validate_on_submit():
                # ...
                db.session.add(user)
                db.session.commit()
                token = user.generate_confirmation_token()
                send_email(user.email, 'Confirm Your Account',
                           'auth/email/confirm', user=user, token=token)
                flash('A confirmation email has been sent to you by email.')
                return redirect(url_for('main.index'))
            return render_template('auth/register.html', form=form)


    - Now, we'll the template for the confirmation email.  For each email, a plain-text template
        and an HTML template are needed.


        # app/templates/auth/email/confirm.txt
        Dear {{ user.username }},
        
        Welcome to Flasky!
        
        To confirm your account please click on the following link:
        
        {{ url_for('auth.confirm', token=token, _external=True) }}
        
        Sincerely,
        
        The Flasky Team
        
        Note: replies to this email address are not monitored.


        # app/templates/auth/email/confirm.html
        <p>Dear {{ user.username }},</p>
        <p>Welcome to <b>Flasky</b>!</p>
        <p>To confirm your account please 
        <a href="{{ url_for('auth.confirm', token=token, _external=True) }}">click here</a>.
        </p>
        <p>Alternatively, you can paste the following link in your browser's address bar:</p>
        <p>{{ url_for('auth.confirm', token=token, _external=True) }}</p>
        <p>Sincerely,</p>
        <p>The Flasky Team</p>
        <p><small>Note: replies to this email address are not monitored.</small></p>


    - Now, we add the view method to call when the link in the confirmation email is clicked.


        # app/auth/views.py
        @auth.route('/confirm/<token>')
        @login_required
        def confirm(token):
            if current_user.confirmed:
                return redirect(url_for('main.index'))
            if current_user.confirm(token):
                db.session.commit()
                flash('You have confirmed your account. Thanks!')
            else:
                flash('The confirmation link is invalid or has expired.')
            return redirect(url_for('main.index'))


      Note that this method is decorated with 'login_required', so the user has to log back in
        to access it.



- Handling Unconfirmed Accounts

    - Each application can decide what unconfirmed users are allowed to do before they 
        confirm their accounts.  One possibility is to allow unconfirmed users to log in, 
        but only show a page that asks them to confirm their accounts before gaining further
        access.

      This step can be done using Flask's 'before_request' hook.  However, from a blueprint,
        the hook only applies to requests that belong to the blueprint.  

      To install a blueprint hook for all application requests, we use the 'before_app_request'
        decorator instead.


    - Here, we filter unconfirmed accounts:

        @auth.before_app_request
        def before_request():
            if current_user.is_authenticated \
                    and not current_user.confirmed \
                    and request.blueprint != 'auth' \
                    and request.endpoint != 'static':
                return redirect(url_for('auth.unconfirmed'))
        
        @auth.route('/unconfirmed')
        def unconfirmed():
            if current_user.is_anonymous or current_user.confirmed:
                return redirect(url_for('main.index'))
            return render_template('auth/unconfirmed.html') 


    - The 'before_app_request' handler intercepts a request when 3 conditions are true:

        1. A user is logged in (current_user.is_authenticated == True)

        2. The user is not confirmed.

        3. The requested URL is outside of the authentication blueprint and is not for a static
             file.  

      If theses 3 are met, a redirect is issed to the '/auth/unconfirmed' route.


    - Note that using the 'before_app_request' hook and a redirect, we can redirect all traffic
        to a specific URL.


    - For unconfirmed users, we just send them a link to get their confirmation email resent.
        Here's the view method for resending it.

        # app/auth/views.py
        @auth.route('/confirm')
        @login_required
        def resend_confirmation():
            token = current_user.generate_confirmation_token()
            send_email(current_user.email, 'Confirm Your Account',
                       'auth/email/confirm', user=current_user, token=token)
            flash('A new confirmation email has been sent to you by email.')
            return redirect(url_for('main.index'))


    - Here's the template we show for logged in users who are still unconfirmed:

        # app/templates/auth/unconfirmed.html
        {% extends "base.html" %}

        {% block title %}Flasky - Confirm your account{% endblock %}
        
        {% block page_content %}
        <div class="page-header">
            <h1>
                Hello, {{ current_user.username }}!
            </h1>
            <h3>You have not confirmed your account yet.</h3>
            <p>
                Before you can access this site you need to confirm your account.
                Check your inbox, you should have received an email with a confirmation link.
            </p>
            <p>
                Need another confirmation email?
                <a href="{{ url_for('auth.resend_confirmation') }}">Click here</a>
            </p>
        </div>
        {% endblock %}



- Handling Password Updates

    - Users may want to change their password.  This is easy, since as long as the user is
        logged in, we can just present them with a form that asks for the old password and
        a new password to replace it.

        # app/auth/views.py
        from .forms import ChangePasswordForm

        @auth.route('/change-password', methods=['GET', 'POST'])
        @login_required
        def change_password():
            form = ChangePasswordForm()
            if form.validate_on_submit():
                if current_user.verify_password(form.old_password.data):
                    current_user.password = form.password.data
                    db.session.add(current_user)
                    db.session.commit()
                    flash('Your password has been updated.')
                    return redirect(url_for('main.index'))
                else:
                    flash('Invalid password.')
            return render_template("auth/change_password.html", form=form)


    - Here is the ChangePasswordForm:

        # app/auth/forms.py

        class ChangePasswordForm(FlaskForm):
            old_password = PasswordField('Old password', validators=[DataRequired()])
            password = PasswordField('New password', validators=[
                DataRequired(), EqualTo('password2', message='Passwords must match.')])
            password2 = PasswordField('Confirm new password',
                                      validators=[DataRequired()])
            submit = SubmitField('Update Password')


    - Here is the template:

        # app/templates/auth/change_password.html

        {% extends "base.html" %}
        {% import "bootstrap/wtf.html" as wtf %}
        
        {% block title %}Flasky - Change Password{% endblock %}
        
        {% block page_content %}
        <div class="page-header">
            <h1>Change Your Password</h1>
        </div>
        <div class="col-md-4">
            {{ wtf.quick_form(form) }}
        </div>
        {% endblock %}


    - Also, we refactor the navbar.  Instead of having a 'Log Out' link, we'll create a dropdown
        with options to either 'Log Out' or 'Change Password'.

        # app/templates/base.html

        <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Account <b class="caret"></b></a>
            <ul class="dropdown-menu">
                <li><a href="{{ url_for('auth.change_password') }}">Change Password</a></li>
                <li><a href="{{ url_for('auth.logout') }}">Log Out</a></li>
            </ul>
        </li>



- Handling Password Resets

    - To avoid locking users out of the application when they forget their passwords, a
        password reset option can be offered.  To implement password resets in a secure way,
        tokens must be used in a way similar to confirmation emails.

      When a user requests a password reset, an email with a reset token is sent to the 
        registered email address.

      The user clicks the link in the email, and after the token is verified, a form is 
        presented where a new password can be entered.


    - Here are the view methods:

        # app/auth/views.py
        from .forms import PasswordResetRequestForm, PasswordResetForm

        @auth.route('/reset', methods=['GET', 'POST'])
        def password_reset_request():
            if not current_user.is_anonymous:
                return redirect(url_for('main.index'))
            form = PasswordResetRequestForm()
            if form.validate_on_submit():
                user = User.query.filter_by(email=form.email.data.lower()).first()
                if user:
                    token = user.generate_reset_token()
                    send_email(user.email, 'Reset Your Password',
                               'auth/email/reset_password',
                               user=user, token=token)
                flash('An email with instructions to reset your password has been '
                      'sent to you.')
                return redirect(url_for('auth.login'))
            return render_template('auth/reset_password.html', form=form)
        
        
        @auth.route('/reset/<token>', methods=['GET', 'POST'])
        def password_reset(token):
            if not current_user.is_anonymous:
                return redirect(url_for('main.index'))
            form = PasswordResetForm()
            if form.validate_on_submit():
                if User.reset_password(token, form.password.data):
                    db.session.commit()
                    flash('Your password has been updated.')
                    return redirect(url_for('auth.login'))
                else:
                    return redirect(url_for('main.index'))
            return render_template('auth/reset_password.html', form=form)


    - Here are the forms for resetting passwords.

        # app/auth/forms.py

        class PasswordResetRequestForm(FlaskForm):
            email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                                     Email()])
            submit = SubmitField('Reset Password')
        
        
        class PasswordResetForm(FlaskForm):
            password = PasswordField('New Password', validators=[
                DataRequired(), EqualTo('password2', message='Passwords must match')])
            password2 = PasswordField('Confirm password', validators=[DataRequired()])
            submit = SubmitField('Reset Password')


    - Here are the model changes required:

        # app/models.py

        def generate_reset_token(self, expiration=3600):
            s = Serializer(current_app.config['SECRET_KEY'], expiration)
            return s.dumps({'reset': self.id}).decode('utf-8')
    
        @staticmethod
        def reset_password(token, new_password):
            s = Serializer(current_app.config['SECRET_KEY'])
            try:
                data = s.loads(token.encode('utf-8'))
            except:
                return False
            user = User.query.get(data.get('reset'))
            if user is None:
                return False
            user.password = new_password
            db.session.add(user)
            return True


    - Here are the templates for the password reset emails.

        # app/templates/auth/email/reset_password.html

        <p>Dear {{ user.username }},</p>
        <p>To reset your password 
            <a href="{{ url_for('auth.password_reset', token=token, _external=True) }}">click here</a>.
        </p>
        <p>Alternatively, you can paste the following link in your browser's address bar:</p>
        <p>{{ url_for('auth.password_reset', token=token, _external=True) }}</p>
        <p>If you have not requested a password reset simply ignore this message.</p>
        <p>Sincerely,</p>
        <p>The Flasky Team</p>
        <p><small>Note: replies to this email address are not monitored.</small></p>


        # app/templates/auth/email/reset_password.txt

        Dear {{ user.username }},

        To reset your password click on the following link:
        
        {{ url_for('auth.password_reset', token=token, _external=True) }}
        
        If you have not requested a password reset simply ignore this message.
        
        Sincerely,
        
        The Flasky Team
        
        Note: replies to this email address are not monitored.


    - Now, we can add the 'Reset Password' link to the login form.

        # app/templates/auth/login.html

        {{ wtf.quick_form(form) }}
        <br>
        <p>Forgot your password? 
            <a href="{{ url_for('auth.password_reset_request') }}">Click here to reset it</a>.
        </p>


    - Finally, we'll add user model tests for the password resets.

        # tests/test_user_model.py

        def test_valid_reset_token(self):
            u = User(password='cat')
            db.session.add(u)
            db.session.commit()
            token = u.generate_reset_token()
            self.assertTrue(User.reset_password(token, 'dog'))
            self.assertTrue(u.verify_password('dog'))
    
        def test_invalid_reset_token(self):
            u = User(password='cat')
            db.session.add(u)
            db.session.commit()
            token = u.generate_reset_token()
            self.assertFalse(User.reset_password(token + 'a', 'horse'))
        self.assertTrue(u.verify_password('cat'))



- Email Address Changes