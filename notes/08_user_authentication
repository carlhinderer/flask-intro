-----------------------------------------------------------------------
|  CHAPTER 8 - USER AUTHENTICATION                                    |
-----------------------------------------------------------------------

- There are many excellent Python authentication packages, but none of them do everything.
    Here, we'll use several packages and provide the glue that holds them together.

  Authentication Packages:

    1. Flask-Login
         Management of user sessions for logged-in users

    2. Werkzeug
         Password hashing and verification

    3. itsdangerous
         Cryptographically secure token generation and verification



- Hashing Passwords with Werkzeug

    - Werzkeug's 'security' module conveniently implements secure password hashing.  It's
        functionality is exposed with 2 simple functions.


        # Takes in plain-text password and returns the password hash
        generate_password_hash(password, method='pbkdf2:sha256', salt_length=8)

        # Takes in password and hash, and returns True if they are the same
        check_password_hash(hash, password)


    - We'll update the 'User' model to accomodate password hashing.


        from werkzeug.security import generate_password_hash, check_password_hash

        class User(db.Model):
            # ...
            password_hash = db.Column(db.String(128))
        
            @property
            def password(self):
                raise AttributeError('password is not a readable attribute')
        
            @password.setter
            def password(self, password):
                self.password_hash = generate_password_hash(password)
        
            def verify_password(self, password):
                return check_password_hash(self.password_hash, password)


    - We can test the password hashing in the shell.

        >>> u = User()
        >>> u.password = 'cat'

        >>> u.password
        AttributeError: password is not a readable attribute

        >>> u.password_hash
        'pbkdf2:sha256:50000$moHwFH1B$ef1574909f9c549285e8547cad181c5e0213cfa44a4aba4349
        fa830aa1fd227f'

        >>> u.verify_password('cat')
        True
        >>> u.verify_password('dog')
        exit
        False



- Testing the Password Hashing

    - We can add tests for the User model:

        # tests/test_user_model.py

        import unittest
        from app.models import User
        
        class UserModelTestCase(unittest.TestCase):
            def test_password_setter(self):
                u = User(password = 'cat')
                self.assertTrue(u.password_hash is not None)
        
            def test_no_password_getter(self):
                u = User(password = 'cat')
                with self.assertRaises(AttributeError):
                    u.password
        
            def test_password_verification(self):
                u = User(password = 'cat')
                self.assertTrue(u.verify_password('cat'))
                self.assertFalse(u.verify_password('dog'))
        
            def test_password_salts_are_random(self):
                u = User(password='cat')
                u2 = User(password='cat')
                self.assertTrue(u.password_hash != u2.password_hash)



- Creating an Authentication Blueprint

    - Blueprints were used in Chapter 7 to define routes in the global scope after the creation
        of the application was moved into a factory function.  In this section, we'll add the
        routes related to the user authentication subsystem into a second blueprint called 'auth'.

      The 'auth' blueprint will be hosted in a Python package with the same name.  


        # app/auth/__init__.py
        from flask import Blueprint

        auth = Blueprint('auth', __name__)

        from . import views


    - Here, we define the route.


        # app/auth/views.py
        from flask import render_template
        from . import auth

        @auth.route('/login')
        def login():
            return render_template('auth/login.html')


    - Also, we need to add the auth blueprint to the 'create_app()' factory function.


        def create_app(config_name):
            # ...
            from .auth import auth as auth_blueprint
            app.register_blueprint(auth_blueprint, url_prefix='/auth')
        
            return app



- User Authentication for Flask-Login

    - Flask-Login is an extension that keeps track of whether users are loggin in.  It can be
        used with any authentication system.

        $ pip install flask-login



- Preparing the User Model for Logins

    - Flask-Login requires these properties on the 'User' model.

        Property/method         Description
        ---------------------------------------------------------------------------------
        is_authenticated        Must be True if the user has valid login credentials or False 
                                  otherwise.

        is_active               Must be True if the user is allowed to log in or False otherwise. 
                                  A False value can be used for disabled accounts.

        is_anonymous            Must always be False for regular users and True for a special 
                                  user object that represents anonymous users.

        get_id()               Must return a unique identifier for the user, encoded as a Unicode 
                                  string.


    - We could directly implement these properties and method in the class, but the Flask-Login
        package includes a 'UserMixin' that has default implementations appropriate for most
        cases.  We also add an email address.


        # app/models.py

        from flask_login import UserMixin

        class User(UserMixin, db.Model):
            ...
            email = db.Column(db.String(64), unique=True, index=True)


    - Flask-Login is initialiazed in the application factory function.


        # app/__init__.py

        from flask_login import LoginManager

        # Sets the endpoint for the login page
        # This will automatically redirect anonymous users when they try to access
        #   protected resources.
        login_manager = LoginManager()
        login_manager.login_view = 'auth.login'

        def create_app(config_name):
            # ...
            login_manager.init_app(app)
            # ...


    - Finally, we need to designate a function that will be used to load a user from the 
        database given its identifier.

        # app/models.py

        from . import login_manager

        @login_manager.user_loader
        def load_user(user_id):
            return User.query.get(int(user_id))



- Protecting Routes

    - To protect a route so that it can only by accessed by authenticated users, Flask-Login
        provides a 'login_required' decorator.

      Here is an example:


        from flask_login import login_required

        @app.route('/secret')
        @login_required
        def secret():
            return 'Only authenticated users are allowed!'


    - If the route is accessed by a user that is not authenticated, Flask-Login will redirect
        the user to the login page.



- Adding a Login Form

    - First, we need to install the 'email_validator' extension.

        $ pip install email_validator


    - Well add a login form:

        # app/auth/forms.py
        from flask_wtf import FlaskForm
        from wtforms import StringField, PasswordField, BooleanField, SubmitField
        from wtforms.validators import DataRequired, Length, Email
        
        class LoginForm(FlaskForm):
            email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                                     Email()])
            password = PasswordField('Password', validators=[DataRequired()])
            remember_me = BooleanField('Keep me logged in')
            submit = SubmitField('Log In')


    - And we'll add 'Log In' and 'Log Out' links depending on the logged-in state of the
        state of the current user.  The links are located in the navbar.

        # app/templates/base.html

        ...
        <ul class="nav navbar-nav navbar-right">
            {% if current_user.is_authenticated %}
            <li><a href="{{ url_for('auth.logout') }}">Log Out</a></li>
            {% else %}
            <li><a href="{{ url_for('auth.login') }}">Log In</a></li>
            {% endif %}
        </ul>



- Signing Users In

    - Now, we can implement the 'login()' view function.

        # app/auth/views.py

        from flask import render_template, redirect, request, url_for, flash
        from flask_login import login_user
        from . import auth
        from ..models import User
        from .forms import LoginForm
        
        @auth.route('/login', methods=['GET', 'POST'])
        def login():
            form = LoginForm()
            if form.validate_on_submit():
                user = User.query.filter_by(email=form.email.data).first()
                if user is not None and user.verify_password(form.password.data):
                    login_user(user, form.remember_me.data)
                    next = request.args.get('next')
                    if next is None or not next.startswith('/'):
                        next = url_for('main.index')
                    return redirect(next)
                flash('Invalid username or password.')
            return render_template('auth/login.html', form=form)


    - The 'remember_me' argument sets whether the user should stay logged in after the browser 
        is closed.

      If the value is False, the user session expires when the browser window is closed, so the
        user will have to log in again each time.

      If the value is True, a long-term cookie will be set in the user's browser, which Flask-Login
        uses to restore the user session.  The optional REMEMBER_COOKIE_DURATION configuration 
        option can be used to change the default one-year duration for the remember cookie.


    - If the login was triggered by a user trying to access a protected resource, Flask-Login will
        have saved that original URL in the 'next' query string argument, which can be accessed
        from the 'request.args' dictionary.  Then we can redirect them to the intended page.

      If there isn't any value for 'next', we redirect the user to the home page.  For safety 
        reasons, we check that it starts with '/' before redirecting to it.


    - Finally, we'll create the template for the login form.

        # app/templates/auth/login.html

        {% extends "base.html" %}
        {% import "bootstrap/wtf.html" as wtf %}
        
        {% block title %}Flasky - Login{% endblock %}
        
        {% block page_content %}
        <div class="page-header">
            <h1>Login</h1>
        </div>
        <div class="col-md-4">
            {{ wtf.quick_form(form) }}
        </div>
        {% endblock %}



- Signing Users Out

    - Here is the implementation of the logout route:

        # app/auth/views.py

        from flask_login import logout_user, login_required

        @auth.route('/logout')
        @login_required
        def logout():
            logout_user()
            flash('You have been logged out.')
            return redirect(url_for('main.index'))



- Understanding How Flask-Login Works

    - Here is the sequence of operations that occurs when a user logs into the system:

        1. The user navigates to 'http://localhost:5000/auth/login' after clicking the link,
             which returns the login form template.


        2. The user enters their username and password and clicks 'Submit', which sends a 
             POST request to the same route.

             A. The handler validates the credentials submitted with the form, then invokes
                  Flask-Login's 'login_user()' function to log the user in.

             B. The 'login_user()' function writes the ID of the user to the user session as
                  a string.

             C. The view function returns with a redirect to the home page.


        3. The browser receives the redirect and requests the home page.

             A. The view function for the home page is invoked, and it triggers rendering of
                  the template.

             B. During the rendering of the template, the 'current_user' appears for the first
                  time.

             C. The 'current_user' context variable does not have a value assigned yet, so it
                  invokes Flask-Login's internal function '_get_user()' to get the user's
                  identity.

             D. The '_get_user()' function check if there is a user ID stored in the user session.
                  If there isn't one, an instance of Flask-Login's 'AnonymousUser' class.

                If there is an ID, it invokes the function that the application registered with
                  the 'user_loader' decorator.

             E. The application's 'user_loader' handler reads the user from the database and 
                  returns it.  Flask-Login assigs it to the 'current_user' context variable for
                  the current request.

             F. The template receives the newly assigned value of 'current_user'.


        4. The 'login_required' decorator builds on top of the 'current_user' context variable by
             only allowing the decorated view function to run when 'current_user.is_authenticated'
             is set to True.


        5. The 'logout_user()' simply deletes the user ID from the user session.



- Testing Logins

    - We'll update our home page to display the name of the logged in user.

        # app/templates/index.html
        <h1>
        Hello,
        {% if current_user.is_authenticated %}
            {{ current_user.username }}
        {% else %}
            Stranger
        {% endif %}!
        </h1>


    - To test this, we can just create a user in the flask shell.

        >>> u = User(email='john@example.com', username='john', password='cat')
        >>> db.session.add(u)
        >>> db.session.commit()



- Adding a User Registration Form

    - When new users want to become members of the application, they must register.  We'll
        create a form for them to enter their email, username, and password.


        # app/auth/forms.py

        from flask_wtf import FlaskForm
        from wtforms import StringField, PasswordField, BooleanField, SubmitField
        from wtforms.validators import DataRequired, Length, Email, Regexp, EqualTo
        from wtforms import ValidationError
        from ..models import User
        
        class RegistrationForm(FlaskForm):
            email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                                     Email()])
            username = StringField('Username', validators=[
                DataRequired(), Length(1, 64),
                Regexp('^[A-Za-z][A-Za-z0-9_.]*$', 0,
                       'Usernames must have only letters, numbers, dots or '
                       'underscores')])
            password = PasswordField('Password', validators=[
                DataRequired(), EqualTo('password2', message='Passwords must match.')])
            password2 = PasswordField('Confirm password', validators=[DataRequired()])
            submit = SubmitField('Register')
        
            def validate_email(self, field):
                if User.query.filter_by(email=field.data).first():
                    raise ValidationError('Email already registered.')
        
            def validate_username(self, field):
                if User.query.filter_by(username=field.data).first():
                    raise ValidationError('Username already in use.')


    - And, we'll add a link to the registration page from the login page.

        # app/templates/auth/login.html

        <p>
            New user?
            <a href="{{ url_for('auth.register') }}">
                Click here to register
            </a>
        </p>



- Registering New Users

    - Here is our view method for registering new users.

        # app/auth/views.py

        @auth.route('/register', methods=['GET', 'POST'])
        def register():
            form = RegistrationForm()
            if form.validate_on_submit():
                user = User(email=form.email.data,
                            username=form.username.data,
                            password=form.password.data)
                db.session.add(user)
                db.session.commit()
                flash('You can now login.')
                return redirect(url_for('auth.login'))
            return render_template('auth/register.html', form=form)



- Generating Confirmation Tokens with itsdangerous

    - A common requirement is to confirm a user can be reached via their email request.
        Typically, the account confirmation procedure involves clicking a specially
        crafted link that includes a confirmation code.

        http://www.example.com/auth/confirm/<confirmation-code>


    - Remember that Flask uses cryptographically signed tokens to protect the content of user
        sessions against tampering.  The user session cookies contain a cryptographic 
        signature generated by a package called 'itsdangerous'.  

      If the contents of the user session is altered, the signature will not match the content
        any more, so Flask discards the session and starts a new one.


    - To generate a signed token:

        >>> from itsdangerous import TimedJSONWebSignatureSerializer as Serializer

        >>> s = Serializer(app.config['SECRET_KEY'], expires_in=3600)
        >>> token = s.dumps({ 'confirm': 23 })
        >>> token
        'eyJhbGciOiJIUzI1NiIsImV4cCI6MTM4MTcxODU1OCwiaWF0IjoxMzgxNzE0OTU4fQ.ey ...'

        >>> data = s.loads(token)
        >>> data
        {'confirm': 23}


    - The 'itsdangerous' package provides several types of token generators.  Among them,
        the 'TimedJSONWebSignatureSerializer' generates JSON Web Signatures (JWSs) with a
        time expiration.  

      The 'dumps()' method generates a cryptographic signature for the data given as an
        argument, then serializes the data plus the signature as a convenient token string.
        The 'expires_in' argument sets a

      The 'loads()' method takes the token and decodes it.


    - We'll add the token generation and verification functionality to the User model.

        # app/models.py

        from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
        from flask import current_app
        from . import db
        
        class User(UserMixin, db.Model):
            # ...
            confirmed = db.Column(db.Boolean, default=False)
        
            def generate_confirmation_token(self, expiration=3600):
                s = Serializer(current_app.config['SECRET_KEY'], expiration)
                return s.dumps({'confirm': self.id}).decode('utf-8')
        
            def confirm(self, token):
                s = Serializer(current_app.config['SECRET_KEY'])
                try:
                    data = s.loads(token.encode('utf-8'))
                except:
                    return False
                if data.get('confirm') != self.id:
                    return False
                self.confirmed = True
                db.session.add(self)
                return True


    - The 'confirm()' method verifies the token and also checks that the id from the token
        matches the logged-in user, so that the token for a given user cannot be used to
        confirm a different user.



- Sending Confirmation Emails

    - 