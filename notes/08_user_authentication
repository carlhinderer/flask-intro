-----------------------------------------------------------------------
|  CHAPTER 8 - USER AUTHENTICATION                                    |
-----------------------------------------------------------------------

- There are many excellent Python authentication packages, but none of them do everything.
    Here, we'll use several packages and provide the glue that holds them together.

  Authentication Packages:

    1. Flask-Login
         Management of user sessions for logged-in users

    2. Werkzeug
         Password hashing and verification

    3. itsdangerous
         Cryptographically secure token generation and verification



- Hashing Passwords with Werkzeug

    - Werzkeug's 'security' module conveniently implements secure password hashing.  It's
        functionality is exposed with 2 simple functions.


        # Takes in plain-text password and returns the password hash
        generate_password_hash(password, method='pbkdf2:sha256', salt_length=8)

        # Takes in password and hash, and returns True if they are the same
        check_password_hash(hash, password)


    - We'll update the 'User' model to accomodate password hashing.


        from werkzeug.security import generate_password_hash, check_password_hash

        class User(db.Model):
            # ...
            password_hash = db.Column(db.String(128))
        
            @property
            def password(self):
                raise AttributeError('password is not a readable attribute')
        
            @password.setter
            def password(self, password):
                self.password_hash = generate_password_hash(password)
        
            def verify_password(self, password):
                return check_password_hash(self.password_hash, password)


    - We can test the password hashing in the shell.

        >>> u = User()
        >>> u.password = 'cat'

        >>> u.password
        AttributeError: password is not a readable attribute

        >>> u.password_hash
        'pbkdf2:sha256:50000$moHwFH1B$ef1574909f9c549285e8547cad181c5e0213cfa44a4aba4349
        fa830aa1fd227f'

        >>> u.verify_password('cat')
        True
        >>> u.verify_password('dog')
        exit
        False



- Testing the Password Hashing

    - We can add tests for the User model:

        # tests/test_user_model.py

        import unittest
        from app.models import User
        
        class UserModelTestCase(unittest.TestCase):
            def test_password_setter(self):
                u = User(password = 'cat')
                self.assertTrue(u.password_hash is not None)
        
            def test_no_password_getter(self):
                u = User(password = 'cat')
                with self.assertRaises(AttributeError):
                    u.password
        
            def test_password_verification(self):
                u = User(password = 'cat')
                self.assertTrue(u.verify_password('cat'))
                self.assertFalse(u.verify_password('dog'))
        
            def test_password_salts_are_random(self):
                u = User(password='cat')
                u2 = User(password='cat')
                self.assertTrue(u.password_hash != u2.password_hash)



- Creating an Authentication Blueprint

    - Blueprints were used in Chapter 7 to define routes in the global scope after the creation
        of the application was moved into a factory function.  In this section, we'll add the
        routes related to the user authentication subsystem into a second blueprint called 'auth'.

      The 'auth' blueprint will be hosted in a Python package with the same name.  


        # app/auth/__init__.py
        from flask import Blueprint

        auth = Blueprint('auth', __name__)

        from . import views


    - Here, we define the route.


        # app/auth/views.py
        from flask import render_template
        from . import auth

        @auth.route('/login')
        def login():
            return render_template('auth/login.html')


    - Also, we need to add the auth blueprint to the 'create_app()' factory function.


        def create_app(config_name):
            # ...
            from .auth import auth as auth_blueprint
            app.register_blueprint(auth_blueprint, url_prefix='/auth')
        
            return app



- User Authentication for Flask-Login

    - Flask-Login is an extension that keeps track of whether users are loggin in.  It can be
        used with any authentication system.

        $ pip install flask-login



- Preparing the User Model for Logins

    - Flask-Login requires these properties on the 'User' model.

        Property/method         Description
        ---------------------------------------------------------------------------------
        is_authenticated        Must be True if the user has valid login credentials or False 
                                  otherwise.

        is_active               Must be True if the user is allowed to log in or False otherwise. 
                                  A False value can be used for disabled accounts.

        is_anonymous            Must always be False for regular users and True for a special 
                                  user object that represents anonymous users.

        get_id()               Must return a unique identifier for the user, encoded as a Unicode 
                                  string.


    - We could directly implement these properties and method in the class, but the Flask-Login
        package includes a 'UserMixin' that has default implementations appropriate for most
        cases.  We also add an email address.


        # app/models.py

        from flask_login import UserMixin

        class User(UserMixin, db.Model):
            ...
            email = db.Column(db.String(64), unique=True, index=True)


    - Flask-Login is initialiazed in the application factory function.


        # app/__init__.py

        from flask_login import LoginManager

        # Sets the endpoint for the login page
        # This will automatically redirect anonymous users when they try to access
        #   protected resources.
        login_manager = LoginManager()
        login_manager.login_view = 'auth.login'

        def create_app(config_name):
            # ...
            login_manager.init_app(app)
            # ...


    - Finally, we need to designate a function that will be used to load a user from the 
        database given its identifier.

        # app/models.py

        from . import login_manager

        @login_manager.user_loader
        def load_user(user_id):
            return User.query.get(int(user_id))



- Protecting Routes

    - To protect a route so that it can only by accessed by authenticated users, Flask-Login
        provides a 'login_required' decorator.

      Here is an example:


        from flask_login import login_required

        @app.route('/secret')
        @login_required
        def secret():
            return 'Only authenticated users are allowed!'


    - If the route is accessed by a user that is not authenticated, Flask-Login will redirect
        the user to the login page.



- Adding a Login Form

    - First, we need to install the 'email_validator' extension.

        $ pip install email_validator


    - Well add a login form:

        # app/auth/forms.py
        from flask_wtf import FlaskForm
        from wtforms import StringField, PasswordField, BooleanField, SubmitField
        from wtforms.validators import DataRequired, Length, Email
        
        class LoginForm(FlaskForm):
            email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                                     Email()])
            password = PasswordField('Password', validators=[DataRequired()])
            remember_me = BooleanField('Keep me logged in')
            submit = SubmitField('Log In')


    - And we'll add 'Log In' and 'Log Out' links depending on the logged-in state of the
        state of the current user.  The links are located in the navbar.

        # app/templates/base.html

        ...
        <ul class="nav navbar-nav navbar-right">
            {% if current_user.is_authenticated %}
            <li><a href="{{ url_for('auth.logout') }}">Log Out</a></li>
            {% else %}
            <li><a href="{{ url_for('auth.login') }}">Log In</a></li>
            {% endif %}
        </ul>



- Signing Users In

    - Now, we can implement the 'login()' view function.

        # app/auth/views.py

        from flask import render_template, redirect, request, url_for, flash
        from flask_login import login_user
        from . import auth
        from ..models import User
        from .forms import LoginForm
        
        @auth.route('/login', methods=['GET', 'POST'])
        def login():
            form = LoginForm()
            if form.validate_on_submit():
                user = User.query.filter_by(email=form.email.data).first()
                if user is not None and user.verify_password(form.password.data):
                    login_user(user, form.remember_me.data)
                    next = request.args.get('next')
                    if next is None or not next.startswith('/'):
                        next = url_for('main.index')
                    return redirect(next)
                flash('Invalid username or password.')
            return render_template('auth/login.html', form=form)


    - The 'remember_me' argument sets whether the user should stay logged in after the browser 
        is closed.

      If the value is False, the user session expires when the browser window is closed, so the
        user will have to log in again each time.

      If the value is True, a long-term cookie will be set in the user's browser, which Flask-Login
        uses to restore the user session.  The optional REMEMBER_COOKIE_DURATION configuration 
        option can be used to change the default one-year duration for the remember cookie.


    - If the login was triggered by a user trying to access a protected resource, Flask-Login will
        have saved that original URL in the 'next' query string argument, which can be accessed
        from the 'request.args' dictionary.  Then we can redirect them to the intended page.

      If there isn't any value for 'next', we redirect the user to the home page.  For safety 
        reasons, we check that it starts with '/' before redirecting to it.


    - Finally, we'll create the template for the login form.

        # app/templates/auth/login.html

        {% extends "base.html" %}
        {% import "bootstrap/wtf.html" as wtf %}
        
        {% block title %}Flasky - Login{% endblock %}
        
        {% block page_content %}
        <div class="page-header">
            <h1>Login</h1>
        </div>
        <div class="col-md-4">
            {{ wtf.quick_form(form) }}
        </div>
        {% endblock %}