-----------------------------------------------------------------------
|  CHAPTER 5 - WEBFORMS WITH WTFORMS                                  |
-----------------------------------------------------------------------

- Representing SQLAlchemy Data as a Form

    - WTForms is a library that provides many fields with server-side validation by default.
        We use the 'Flask-WTF' extension that integrates WTForms with Flask.

        $ pip install Flask-WTF


    - First, we will create a 'ProductForm' class to represent the fields in the form.  Note
        that the 'coerce' option on the category means the category will be coerced to an integer
        value prior to any validation or processing.

        # models.py
        -------------------------------------------
        from flask_wtf import FlaskForm 
        from wtforms import StringField, DecimalField, SelectField 
         
        class ProductForm(FlaskForm): 
            name = StringField('Name') 
            price = DecimalField('Price') 
            category = SelectField('Category', coerce=int)


    - Now, we can add a handler for the form.

        # views.py
        -------------------------------------------
        from my_app.catalog.models import ProductForm 
 
        @catalog.route('/product-create', methods=['GET', 'POST']) 
        def create_product(): 
            form = ProductForm(csrf_enabled=False) 
         
            categories = [(c.id, c.name) for c in Category.query.all()] 
            form.category.choices = categories 
         
            if request.method == 'POST': 
                name = form.name.data 
                price = form.price.data 
                category = Category.query.get_or_404( 
                    form.category.data 
                ) 
                product = Product(name, price, category) 
                db.session.add(product) 
                db.session.commit() 
                flash('The product %s has been created' % name, 'success') 
                return redirect(url_for('catalog.product', id=product.id)) 
            return render_template('product-create.html', form=form)


    - And we can add our form to the 'product-create' template.

        # templates/product-create.html
        -------------------------------------------
        {% extends 'home.html' %} 
 
        {% block container %} 
          <div class="top-pad"> 
            <form method="POST" action="{{ 
               url_for('catalog.create_product') }}" role="form"> 
              <div class="form-group">{{ form.name.label }}: {{ form.name() }}
              </div> 
              <div class="form-group">{{ form.price.label }}: {{ form.price() }}
              </div> 
              <div class="form-group">{{ form.category.label }}: {{ form.category() }}
              </div> 
              <button type="submit" class="btn btn-default">Submit</button> 
            </form> 
          </div> 
        {% endblock %} 



- Validating Fields on the Server Side

    - It's pretty easy to add validations to WTForms fields.

        # models.py
        -------------------------------------------
        from decimal import Decimal 
        from wtforms.validators import InputRequired, NumberRange 
         
        class ProductForm(FlaskForm): 
            name = StringField('Name', validators=[InputRequired()]) 
            price = DecimalField('Price', validators=[ 
                InputRequired(), NumberRange(min=Decimal('0.0')) 
            ]) 
            category = SelectField( 
                'Category', validators=[InputRequired()], coerce=int
            )


    - Then we have to modify our view method:

        # views.py
        -------------------------------------------
        def create_product():
            ...
            if request.method == 'POST' and form.validate(): 
                ... same as before ...
 
            if form.errors: 
                flash(form.errors, 'danger')


    - Note that we can also use the method:

         if form.validate_on_submit():
             ...

      Which is equivalent to:

         if request.method == 'POST' and form.validate():
             ...



- Creating a Common Forms Set

    - Since many forms use common fields with common validators, it is useful to create
        reusable form parts.

      In our application, we'll have a form for products and a form for categories.  We'll
        create a common form since they'll both use the product name.


        # models.py
        -------------------------------------------
        class NameForm(FlaskForm): 
            name = StringField('Name', validators=[InputRequired()]) 
         
        class ProductForm(NameForm): 
            price = DecimalField('Price', validators=[ 
                InputRequired(), NumberRange(min=Decimal('0.0')) 
            ]) 
            category = SelectField( 
                'Category', validators=[InputRequired()], coerce=int 
            ) 
         
        class CategoryForm(NameForm): 
            pass


    - We'll add a new view method for creating categories.

        # views.py
        -------------------------------------------
        @catalog.route('/category-create', methods=['GET', 'POST']) 
        def create_category(): 
            form = CategoryForm(csrf_enabled=False) 
         
            if form.validate_on_submit(): 
                name = form.name.data 
                category = Category(name) 
                db.session.add(category) 
                db.session.commit() 
                flash('The category %s has been created' % name, 'success') 
                return redirect(url_for('catalog.category', id=category.id)) 
         
            if form.errors: 
                flash(form.errors) 
         
            return render_template('category-create.html', form=form)



- Creating Custom Fields and Validation

    - So far, we have populated the values for the product categories in the SelectField
        on GET requests.  

      We want to create a custom field that takes care of this for us.

        # models.py
        -------------------------------------------
        class CategoryField(SelectField): 
 
            def iter_choices(self): 
                categories = [(c.id, c.name) for c in Category.query.all()] 
                for value, label in categories: 
                    yield (value, label, self.coerce(value) == self.data) 
         
            def pre_validate(self, form): 
                for v, _ in [(c.id, c.name) for c in Category.query.all()]: 
                    if self.data == v: 
                        break 
                else: 
                    raise ValueError(self.gettext('Not a valid choice')) 
         
        class ProductForm(NameForm): 
            price = DecimalField('Price', validators=[ 
                InputRequired(), NumberRange(min=Decimal('0.0')) 
            ]) 
            category = CategoryField( 
                'Category', validators=[InputRequired()], coerce=int 
            ) 


    - We can also create custom validations.  Here, we'll check for duplicate categories.

        # models.py
        -------------------------------------------
        from wtforms.validators import ValidationError 
 
        def check_duplicate_category(case_sensitive=True): 
            def _check_duplicate(form, field): 
                if case_sensitive: 
                    res = Category.query.filter( 
                        Category.name.like('%' + field.data + '%') 
                    ).first() 
                else: 
                    res = Category.query.filter( 
                        Category.name.ilike('%' + field.data + '%') 
                    ).first() 
                if res: 
                    raise ValidationError( 
                        'Category named %s already exists' % field.data 
                    ) 
            return _check_duplicate 
         
        class CategoryForm(NameForm): 
            name = StringField('Name', validators=[ 
                InputRequired(), check_duplicate_category() 
            ])



- Creating a Custom Widget

- Uploading Files via Forms

- Protecting Applications from CSRF