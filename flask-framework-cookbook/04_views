-----------------------------------------------------------------------
|  CHAPTER 4 - WORKING WITH VIEWS                                     |
-----------------------------------------------------------------------

- Writing function-based views and URL routes

    - In earlier versions, Flask only had function-based views.  In later versions, 
        Flask introduced the concept of pluggable views, which allows us to have classes
        and then write methods in the classes.


    - Here is a simple function-based view.  It looks for a parameter in the query string.

        @app.route('/a-get-request') 
        def get_request(): 
            bar = request.args.get('foo', 'bar') 
            return 'A simple Flask request where foo is %s' % bar


    - Here is a simple POST request.  It looks for a parameter from the form submitted.

        @app.route('/a-post-request', methods=['POST']) 
        def post_request(): 
            bar = request.form.get('foo', 'bar') 
            return 'A simple Flask request where foo is %s' % bar


    - Here, we combine GET and POST requests into a single view function.

        @app.route('/a-request', methods=['GET', 'POST']) 
        def some_request(): 
            if request.method == 'GET': 
                bar = request.args.get('foo', 'bar') 
            else: 
                bar = request.form.get('foo', 'bar') 
            return 'A simple Flask request where foo is %s' % bar


    - Sometimes, we want to have a URL map kind of pattern, where we define all the rules
        in a single place rather than scattering them around the application.

        def get_request(): 
            bar = request.args.get('foo', 'bar') 
            return 'A simple Flask request where foo is %s' % bar 
        
        app = Flask(__name__) 
        app.add_url_rule('/a-get-request', view_func=get_request)



- Writing class-based views

    - Flask introduced the concept of pluggable views in version 0.7.  This added a lot of 
        flexibility to the existing implementation.


    - Flask provides a class named 'View', which can be inherited in order to add custom
        behavior.  Here is a simple GET request.

        from flask.views import View 
 
        class GetRequest(View): 
            def dispatch_request(self): 
                bar = request.args.get('foo', 'bar') 
                return 'A simple Flask request where foo is %s' % bar 
         
        app.add_url_rule( 
            '/a-get-request', view_func=GetRequest.as_view('get_request') 
        ) 


    - To accommodate both GET and POST requests, we can write the following code:

        from flask.views import View 
         
        class GetPostRequest(View): 
            methods = ['GET', 'POST'] 
         
            def dispatch_request(self): 
                if request.method == 'GET': 
                    bar = request.args.get('foo', 'bar') 
                if request.method == 'POST': 
                    bar = request.form.get('foo', 'bar') 
                return 'A simple Flask request where foo is %s' % bar 
         
        app.add_url_rule( 
            '/a-request', view_func=GetPostRequest.as_view('a_request') 
        )


    - There is also a way to just declare 'get' and 'post' methods inside a View class
        and let Flask handle the rest.  To do this, we use the 'MethodView'.

        from flask.views import MethodView 

        class GetPostRequest(MethodView): 
            def get(self): 
                bar = request.args.get('foo', 'bar') 
                return 'A simple Flask request where foo is %s' % bar 
         
            def post(self): 
                bar = request.form.get('foo', 'bar') 
                return 'A simple Flask request where foo is %s' % bar 
         
        app.add_url_rule( 
            '/a-request', view_func=GetPostRequest.as_view('a_request') 
        )



- Implementing URL routing

    - Let's say we this URL route.  It will return a string from the URL.

        @app.route('/test/<name>') 
        def get_name(name): 
            return name


    - To validate the length of the argument:

        @app.route('/test/<string(minlength=2,maxlength=3):code>') 
        def get_name(code): 
            return code


    - To accept an integer as an argument:

        @app.route('/test/<int:age>') 
        def get_age(age): 
            return str(age)


    - To validate the minimum and maximum accepted integer:

        @app.route('/test/<int(min=18,max=99):age>')



- Product-Based Pagination

    - Let's modify the 'products()' method to list projects to support pagination.

        @catalog.route('/products') 
        @catalog.route('/products/<int:page>') 
        def products(page=1): 
            products = Product.query.paginate(page, 10).items 
            res = {} 
            for product in products: 
                res[product.id] = { 
                    'name': product.name, 
                    'price': product.price, 
                    'category': product.category.name 
                } 
            return jsonify(res)



- Rendering to templates

    - Here, we render templates in our view method responses.

        from flask import render_template 
 
        @catalog.route('/') 
        @catalog.route('/home') 
        def home(): 
            return render_template('home.html')

        @catalog.route('/product/<id>') 
        def product(id): 
            product = Product.query.get_or_404(id) 
            return render_template('product.html', product=product)      

        @catalog.route('/products') 
        @catalog.route('/products/<int:page>') 
        def products(page=1): 
            products = Product.query.paginate(page, 10) 
            return render_template('products.html', products=products) 


    - Here are our new templates.

        # my_app/templates/home.html
        -------------------------------------------
        {% extends 'base.html' %} 
 
        {% block container %} 
          <h1>Welcome to the Catalog Home</h1> 
          <a href="{{ url_for('catalog.products') }}">Click here to see 
             the catalog</a> 
        {% endblock %}


        # my_app/templates/product.html
        -------------------------------------------
        {% extends 'home.html' %} 
 
        {% block container %} 
          <div class="top-pad"> 
            <h1>{{ product.name }}<small> {{ product.category.name 
               }}</small></h1> 
            <h3>{{ product.price }}</h3> 
          </div> 
        {% endblock %} 


        # my_app/templates/products.html
        -------------------------------------------
        {% extends 'home.html' %} 
 
        {% block container %} 
          <div class="top-pad"> 
            {% for product in products.items %} 
              <div class="well"> 
                <h2> 
                  <a href="{{ url_for('catalog.product', id=product.id) 
                     }}">{{ product.name }}</a> 
                  <small>$ {{ product.price }}</small> 
                </h2> 
              </div> 
            {% endfor %} 
            {% if products.has_prev %} 
              <a href="{{ url_for(request.endpoint, page=products.prev_num) }}"> 
                {{"<< Previous Page"}} 
              </a> 
            {% else %} 
              {{"<< Previous Page"}} 
            {% endif %} | 
            {% if products.has_next %} 
              <a href="{{ url_for(request.endpoint, page=products.next_num) }}"> 
                {{"Next page >>"}} 
              </a> 
            {% else %} 
              {{"Next page >>"}} 
            {% endif %} 
          </div> 
        {% endblock %}



- Dealing with XHR requests

    - Asynchronous XmlHttpRequests have been getting more and more prominent with the rise
        of SPA frameworks like Angular, Vue, and React.


    - The Flask 'request' object has a flag called 'is_xhr' which tells us whether the request
        made is an XHR.  If it is, the called typically expects the result in JSON.  

      For instance, if we get an XHR to the home route, we assume the client wants to reload
        the product list.

        from flask import request, render_template, jsonify 
 
        @catalog.route('/') 
        @catalog.route('/home') 
        def home(): 
            if request.is_xhr: 
                products = Product.query.all() 
                return jsonify({ 
                    'count': len(products) 
                }) 
            return render_template('home.html')


    - Next, we add a 'scripts' block to our base template.

        # my_app/templates/base.html
        -------------------------------------------
        {% block scripts %}
        {% endblock %}


    - Finally, we modify our home template, which checks whether the request is an XHR
        request.  If it is, it fetches the list of products from the database and returns
        it as a JSON object.  A badge is shown which displays the number of products in
        the database.

        # my_app/templates/home.html
        -------------------------------------------
        {% extends 'base.html' %} 
 
        {% block container %} 
          <h1>Welcome to the Catalog Home</h1> 
          <a href="{{ url_for('catalog.products') }}" id="catalog_link"> 
            Click here to see the catalog 
          </a> 
        {% endblock %} 
         
        {% block scripts %} 
        <script> 
        $(document).ready(function(){ 
          $.getJSON("/home", function(data) { 
            $('#catalog_link').append('<span class="badge">' + data.count 
               + '</span>'); 
          }); 
        }); 
        </script> 
        {% endblock %} 



- Using decorators to handle requests beautifully

- Creating custom 404 and 500 handlers

- Flashing messages for better user feedback

- Implementing SQL-based searching