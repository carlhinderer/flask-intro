-----------------------------------------------------------------------
|  CHAPTER 2 - TEMPLATING WITH JINJA2                                 |
-----------------------------------------------------------------------

- Bootstrapping the recommended layout

    - By default, Flask expects templates to be placed inside a folder named 'templates'
        at the application root level.  If this folder is present, Flask will automatically
        make the contents of this folder available for the 'render_template' method.


    - We'll add a 'templates' folder to our project.

        flask_app/ 
            - run.py 
            my_app/ 
                - __init__.py 
                - hello/ 
                    - __init__.py 
                    - views.py 
                - templates 


    - Here is new view method, which renders a template.  It looks for a 'user' argument in 
        the query string.

        # my_app/hello/views.py
        -------------------------------------------
        from flask import render_template, request 

        @hello.route('/') 
        @hello.route('/hello') 
        def hello_world(): 
            user = request.args.get('user', 'Shalabh') 
            return render_template('index.html', user=user)


    - Here is the template rendered from the view method:

        # my_app/templates/index.html
        -------------------------------------------
        <html> 
          <head> 
            <title>Flask Framework Cookbook</title> 
          </head> 
          <body> 
            <h1>Hello {{ user }}!</h1> 
            <p>Welcome to the world of Flask!</p> 
          </body> 
        </html>



- Implementing block composition and layout inheritance

    - It's a good practice to have a base template where the basic layout of the site, along
        with the header and footer, can be structured.


    - We'll create an application that uses Bootstrap styles.

          flask_app/ 
              - run.py 
              my_app/ 
                  - __init__.py 
                  - product/ 
                      - __init__.py 
                      - views.py 
                      - models.py 
                  - templates/ 
                      - base.html 
                      - home.html 
                      - product.html 
                  - static/ 
                      - js/ 
                          - bootstrap.min.js 
                      - css/ 
                          - bootstrap.min.css 
                          - main.css


    - We'll simulate a simple e-commerce website.  To start, we'll add some products to our
        models.

        # my_app/product/models.py
        -------------------------------------------
        PRODUCTS = { 
            'iphone': { 
                'name': 'iPhone 5S', 
                'category': 'Phones', 
                'price': 699, 
            },  
            'galaxy': { 
                'name': 'Samsung Galaxy 5', 
                'category': 'Phones', 
                'price': 649, 
            }, 
            'ipad-air': { 
                'name': 'iPad Air', 
                'category': 'Tablets', 
                'price': 649, 
            }, 
            'ipad-mini': { 
                'name': 'iPad Mini', 
                'category': 'Tablets', 
                'price': 549 
            } 
        }


    - Next, we'll add the views.

        # my_app/product/views.py
        -------------------------------------------
        from werkzeug import abort 
        from flask import render_template 
        from flask import Blueprint 
        from my_app.product.models import PRODUCTS 
         
        product_blueprint = Blueprint('product', __name__) 
         
        @product_blueprint.route('/') 
        @product_blueprint.route('/home') 
        def home(): 
            return render_template('home.html', products=PRODUCTS) 
         
        @product_blueprint.route('/product/<key>') 
        def product(key): 
            product = PRODUCTS.get(key) 
            if not product: 
                abort(404) 
            return render_template('product.html', product=product)


    - Here, we create the application's configuration file.

        # my_app/__init__.py
        -------------------------------------------
        from flask import Flask 
        from my_app.product.views import product_blueprint 
         
        app = Flask(__name__) 
        app.register_blueprint(product_blueprint) 
 

    - Here is the custom CSS we will use:

        # my_app/static/css/main.css
        -------------------------------------------
        body { 
          padding-top: 50px; 
        } 
        .top-pad { 
          padding: 40px 15px; 
          text-align: center; 
        }


    - Here is the base template:

        # my_app/templates/base.html
        -------------------------------------------
        <!DOCTYPE html> 
        <html lang="en"> 
          <head> 
            <meta charset="utf-8"> 
            <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
            <meta name="viewport" content="width=device-width, initial-
               scale=1"> 
            <title>Flask Framework Cookbook</title> 
            <link href="{{ url_for('static', 
               filename='css/bootstrap.min.css') }}" rel="stylesheet"> 
            <link href="{{ url_for('static', filename='css/main.css') }}" 
               rel="stylesheet"> 
          </head> 
          <body> 
            <div class="navbar navbar-inverse navbar-fixed-top" 
               role="navigation"> 
              <div class="container"> 
                <div class="navbar-header"> 
                  <a class="navbar-brand" href="{{ url_for('product.home') 
                     }}">Flask Cookbook</a> 
                </div> 
              </div> 
            </div> 
            <div class="container"> 
              {% block container %}{% endblock %} 
            </div> 
         
            <!-- jQuery (necessary for Bootstrap's JavaScript plugins) --> 
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/
               2.0.0/jquery.min.js"></script> 
            <script src="{{ url_for('static', filename='js/
               bootstrap.min.js') }}"></script> 
          </body> 
        </html>


    - Now on the home page for our application, we'll display the products.

        # my_app/templates/home.html
        -------------------------------------------
        {% extends 'base.html' %} 
 
        {% block container %} 
          <div class="top-pad"> 
            {% for id, product in products.items() %} 
              <div class="well"> 
                <h2> 
                  <a href="{{ url_for('product.product', key=id) }}">{{ 
                     product['name'] }}</a> 
                  <small>$ {{ product['price'] }}</small> 
                </h2> 
              </div> 
            {% endfor %} 
          </div> 
        {% endblock %}


    - And we'll create a page for individual products.

        # my_app/templates/product.html
        -------------------------------------------
        {% extends 'home.html' %} 
 
        {% block container %} 
          <div class="top-pad"> 
            <h1>{{ product['name'] }} 
              <small>{{ product['category'] }}</small> 
            </h1> 
            <h3>$ {{ product['price'] }}</h3> 
          </div> 
        {% endblock %}



- Creating a custom context processor

    - We want to avoid putting programming logic in templates, so if we have some value
        we want to calculate, we can put it in a Python method and return the value to
        the template.  This method is called a 'context processor'.


    - Here is our custom context processor.

        # my_app/product/views.py
        -------------------------------------------
        @product_blueprint.context_processor
        def product_name_processor(): 
            def full_name(product): 
                return '{0} / {1}'.format(product['category'], 
                   product['name']) 
            return {'full_name': full_name}


    - Then we can use the context processor.

        {{ full_name(product) }} 



- Creating a custom Jinja2 filter

    - We can write a filter to accomplish the same logic in a cleaner way.  Here is
        the filter:

        @product_blueprint.app_template_filter('full_name') 
        def full_name_filter(product): 
            return '{0} / {1}'.format(product['category'], product['name']) 


    - To use the filter:

        {{ product | full_name }}


    - In another example, we use the 'ccy' external library to format currency.

        $ pip install ccy


        # my_app/__init__.py
        -------------------------------------------
        import ccy 
        from flask import request 
         
        @app.template_filter('format_currency') 
        def format_currency_filter(amount): 
            currency_code = ccy.countryccy(request.accept_languages.best[-2:]) 
            return '{0} {1}'.format(currency_code, amount)


    - To use this filter:

        <h3>{{ product['price'] | format_currency }}</h3>



- Creating a custom macro for forms

- Advanced date and time formatting



-------------------------------------------
